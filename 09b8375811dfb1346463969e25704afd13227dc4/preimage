#!/bin/bash
# cperl rebase all branches above master.
# before git push cp -f (update all dependent branches)
# now also with cp-rbi functionality with -i
# ./cp-rb 1 (does 1 skip)
if [ x$1 = x-f ]; then force=1; shift; fi
if [ x$1 = x--hard ]; then hard=1; shift; fi
if [ x$1 = x-i ]; then interactive=--interactive; shift; fi
case $1 in
    [0-9]*) rbs=$1; shift;;
esac

#set -e

function do_exit {
    echo 'g co feature/CM-317-cperl-signatures3; g rb master; g rbs'
    echo 'g co feature/CM-367-cperl-carp-builtin; g rb master; g rbs'
    echo 'g co feature/CM-367-cperl-warnings-xs-carp; g rb feature/CM-367-cperl-carp-builtin; g rbs'
    echo 'g co feature/CM-370-cperl-warnings-xs; g rb master; g rbs'
    echo
    git rebase --abort
    exit
}

trap do_exit ERR
set -e

function rb {
    b=$1
    m=$2
    echo git rebase $m --onto $b
    if [ -n $force ]; then git checkout -f $b; fi
<<<<<<<
    # if the rb exit happens in an old to be merged commit, do a --skip (g rbs),
    # if it happens in the new branch, resolve it manually
    git checkout $b && git rebase $m
    if [ x$? != x0 ]; then
    	echo "rebase exit code:" $?
    	do_exit
    fi
    git checkout master
=======
    git checkout $b && git rebase $interactive $m
    if [ x$? != x0 ]; then
        # if the rb exit happens in an old to be merged commit, do a --skip (g rbs),
        # optionally execute ARG1 skips ($rbs)
        # if it happens in the new branch, resolve it manually
        if [ x$rbs != x ]; then
            echo git rebase --skip $rbs x
            for i in `seq 1 $rbs`; do
                git rebase --skip
            done
        fi
    fi
    if [ -e .git/rebase-apply/patch ]; then
       exit
    fi
    git checkout branch-point
}

function rbb {
    rb $1 branch-point
>>>>>>>
}

# merge-upstream - master - branch-point
# we work above branch-point and move stable tress to master

# not yet merged features or bugfixes, branched of from branch-point or merge-upstream
git checkout branch-point
rb branch-point master
for b in `git branch --no-color | egrep '(bugfix|compiler|feature)/'`; do
    if [ -n $hard ]; then git reset --hard; fi
<<<<<<<
    rb $b branch-point
=======
    rb $b master
done

# compiler branches:
rb feature/CM-600-cperl-cowrefcnt-stats     master
rb feature/CM-600-cperl-cowrefcnt	    feature/CM-600-cperl-cowrefcnt-stats

# speed branches:
# unstable side-branches, branching off somewhere
rb feature/CM-626-cperl-use-dots    master
rb feature/CM-317-cperl-signatures  master
rb feature/CM-317-cperl-signatures3 master
rb feature/CM-317-cperl-signatures3-CM-690-nl feature/CM-317-cperl-signatures3
rb feature/CM-317-cperl-signatures3-CM-690-nl1 feature/CM-317-cperl-signatures3
#rb feature/CM-712-cperl-types-pp    feature/CM-317-cperl-signatures3
#rb feature/CM-712-cperl-types-proto feature/CM-712-cperl-types-pp

# memory branches:
rb feature/CM-367-cperl-carp-builtin     master
rb feature/CM-367-cperl-warnings-xs-carp feature/CM-367-cperl-carp-builtin
rb feature/CM-370-cperl-warnings-xs      master

# speed list: our pretty stable branch linear hierarchy
declare -a feat
feat=(master feature/CM-317-cperl-signatures3 feature/CM-712-cperl-types-pp feature/CM-712-cperl-types-proto)
N=4
for i in `seq 0 $(($N - 2))`; do
    n=$(($i + 1))
    rb ${feat[$n]} ${feat[$i]}
>>>>>>>
done

<<<<<<<
# memory branches:
rb featurex/CM-367-cperl-warnings-xs-carp feature/CM-367-cperl-carp-builtin

# speed and feature list: our previous pretty stable branch linear hierarchy
rb featurex/gh16-multi feature/gh7-signatures

# (for later deeper subtrees)
#declare -a feat
#feat=(feature/gh7-signatures
#      featurex/gh16-multi
#     )
#N=${#feat[@]}
#for i in `seq 0 $(($N - 2))`; do
#    n=$(($i + 1))
#    rb ${feat[$n]} ${feat[$i]}
#done

# defunct:
#rb old/gh7-signatures3-gh25-nl  feature/gh7-signatures
#rb old/gh7-signatures3-gh25-nl1 feature/gh7-signatures

git checkout branch-point
git branch | egrep 'branch-point|master|bugfix/|feature'
=======
git branch | egrep 'master|bugfix/|feature/|merge-'
>>>>>>>
